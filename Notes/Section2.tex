%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Written By Michael Brodskiy
% Class: Fundamentals of Networks
% Professor: E. Bernal Mor
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\include{Includes.tex}

\title{The Application Layer}
\date{\today}
\author{Michael Brodskiy\\ \small Professor: E. Bernal Mor}

\begin{document}

\maketitle

\begin{itemize}

  \item Network Applications

    \begin{itemize}

      \item Social networking

      \item Web

      \item Text messaging

      \item E-mail

      \item Multi-user network games

      \item Streaming stored video (YouTube, Hulu, Netflix)

      \item P2P File Sharing

      \item And many more

    \end{itemize}

  \item Creating Network Applications

    \begin{itemize}

      \item Write programs that:

        \begin{itemize}

          \item Run on (different) end systems

          \item Communicate over network

          \item For example, web server software communicates with browser software

        \end{itemize}

      \item No need to write software for network-core devices (intermediate nodes)

        \begin{itemize}

          \item Network-core devices do not run user applications

          \item Applications on end systems allow for rapid application development and propagation

        \end{itemize}

    \end{itemize}

  \item Application Architecture

    \begin{itemize}

      \item Network architecture — a set of layers and protocols

        \begin{itemize}

          \item It is fixed, and provides the network application developer with specific set of services

        \end{itemize}

      \item Application Architecture — define how the application is structured over various end systems

        \begin{itemize}

          \item Designed by the application developer

          \item Predominant architectural paradigms

            \begin{itemize}

              \item Client-server

              \item Peer-to-peer (P2P)

            \end{itemize}

        \end{itemize}

    \end{itemize}

  \item Client-server Architecture

    \begin{itemize}
        
      \item Server

        \begin{itemize}

          \item Always-on host

          \item Permanent IP-address (like ID)

          \item Often in data centers, for scaling

        \end{itemize}

      \item Clients

        \begin{itemize}

          \item Contact, communicate with server

          \item May be intermittently connected

          \item May have dynamic IP addresses

          \item Do not communicate directly with each other

        \end{itemize}

      \item Examples: HTTP, IMAP, SFTP

    \end{itemize}

  \item Peer-Peer (P2P) Architecture

    \begin{itemize}

      \item No always-on server

      \item Arbitrary end systems directly communicate

      \item Peers request service from other peers, provide service in return to other peers

        \begin{itemize}

          \item Self scalability — new peers bring new service capacity, as well as new service demands

        \end{itemize}

      \item Peers are intermittently connected and change IP addresses 

        \begin{itemize}

          \item Complex management

        \end{itemize}

      \item Example: P2P File Sharing

    \end{itemize}

  \item Process Communication

    \begin{itemize}

      \item Process — program running within a host

        \begin{itemize}

          \item Within same host, two processes communicate using inter-process communication, defined by OS (Operating System)

          \item Processes in different hosts communicate by exchansing messages

        \end{itemize}

      \item Client process — process that initiates communication

      \item Server process — process that wants to be contacted

      \item Note: applications with P2P architectures have client processes 7& server processes

    \end{itemize}

  \item Sockets

    \begin{itemize}

      \item Process send/receives messages to/from its socket

      \item Socket analogous to door

        \begin{itemize}

          \item Sending process shoves message out the door

          \item Sending process relies on transport infrastructure on other side of door to deliver message to socket at receiving process

        \end{itemize}

    \end{itemize}

  \item Addressing Processes

    \begin{itemize}

      \item To receive messages, a process must have an identifier

      \item Host device has a unique IP address

      \item Identifier includes both IP address and port numbers associated with process on host

        \begin{itemize}

          \item HTTP server: 80

          \item Mail server: 25

        \end{itemize}

      \item To send HTTP message to gaia.cs.umass.edu web server:

        \begin{itemize}

          \item IP address: 128.119.245.12

          \item Port number: 80

        \end{itemize}

    \end{itemize}

  \item An Application Layer Protocol Defines:

    \begin{itemize}

      \item Types of messages exchanged

        \begin{itemize}

          \item Example: request, response

        \end{itemize}

      \item Message syntax

        \begin{itemize}

          \item What fields in messages \& how fields are delineated

        \end{itemize}

      \item Message semantics

        \begin{itemize}

          \item Meaning of information in fields

        \end{itemize}

      \item Rules for when and how processes send \& respond to messages

    \end{itemize}

  \item Application Layer Protocols can be

    \begin{itemize}

      \item Open protocols

        \begin{itemize}

          \item Defined in RFCs, everyone has access to protocol definition

          \item Allows for interoperability

          \item Example: HTTP, SMTP

        \end{itemize}

      \item Proprietary protocols

        \begin{itemize}

          \item Example: Skype

        \end{itemize}

    \end{itemize}

  \item Transport Layer Services for Applications

    \begin{itemize}

      \item Transport layer is on the other side of the ``door''

      \item There are multiple Transport-layer protocols that provide different services

      \item The application developer must choose a Transport-layer protocol, depending on the services needed by the application

        \begin{itemize}

          \item Examples: priority mail, express mail, certified mail

        \end{itemize}

      \item A Transport-layer protocol can provide a different array of services

    \end{itemize}

  \item Transport Services

    \begin{itemize}

      \item Data integrity/reliable transport

        \begin{itemize}

          \item Some apps (\textit{e}.\textit{g}.\ file transfer, web transactions) require 100\% reliable data transfer

          \item Other apps (\textit{e}.\textit{g}.\ audio) can tolerate some loss

        \end{itemize}

      \item Timing

        \begin{itemize}

          \item Some apps (\textit{e}.\textit{g}. Internet telephony, interactive games) require low delay to be ``effective''

        \end{itemize}

      \item Throughput

        \begin{itemize}

          \item Some apps (e.g., multimedia) require minimum amount of throughput to be ``effective''

          \item Other apps (``elastic apps'') make use of whatever throughput they get

        \end{itemize}

      \item Security

        \begin{itemize}

          \item Encryption, data integrity, \ldots

        \end{itemize}

    \end{itemize}

  \item Internet Transport Protocol Services

    \begin{itemize}

      \item TCP Service

        \begin{itemize}

          \item Reliable transport between sending and receiving processes

          \item Flow control — sender will not overwhelm receiver

          \item Congestion control — throttle sender when network overloaded

          \item Does not provide timing, minimum throughput guarantee, security

          \item Connection-oriented service: setup required between client and service processes

        \end{itemize}

      \item UDP Service:

        \begin{itemize}

          \item Unreliable data transfer between sending and receiving process

          \item Does not provide reliability, flow control, congestion control, timing, throughput guarantee, security, or connection setup

          \item Connectionless service: no setup required

        \end{itemize}

    \end{itemize}

  \item Vanilla TCP \& UDP sockets

    \begin{itemize}

      \item No encryption

      \item Clear text passwords sent into socket traverse Internet in clear text

    \end{itemize}

  \item Transport Layer Security (TLS)

    \begin{itemize}

      \item Provides encrypted TCP connections

      \item Data integrity

      \item End-point authentication

      \item TSL implemented in Application Layer

        \begin{itemize}

          \item Applications use TLS libraries, that use TCP in turn

        \end{itemize}

      \item TLS socket API

        \begin{itemize}

          \item Clear text sent into socket traverse Internet encrypted

        \end{itemize}

      \item Datagram Transport Layer Service (DTLS) protocol

        \begin{itemize}

          \item Adaptation of TLS to run over connectionless protocols such as UDP

        \end{itemize}

    \end{itemize}

  \item Designing Network Applications

    \begin{itemize}

      \item It is a complex process

      \item Requires knowledge of programming, software engineering, and networking

      \item From a networking point of view, there are two major decisions:

        \begin{enumerate}

          \item Type of application (aka Application Architecture)

            \begin{itemize}

              \item Client-server vs.\ peer-to-peer

            \end{itemize}

          \item Services requested to the Transport Layer

            \begin{itemize}

              \item \textit{E}.\textit{g}.\  reliable vs. unreliable data transfer

            \end{itemize}

        \end{enumerate}

    \end{itemize}

  \item Web and HTTP

    \begin{itemize}

      \item Web page consists of several objects, each of which can be store on different Web servers

      \item Object can be HTML, JPEG, Java applet, audio file, etc.

      \item Web page consists of a base HTML-file, which includes several referenced objects

      \item Each object is addressable by a URL (Uniform Resource Locator), \textit{e}.\textit{g}.,

        \begin{center}
          $\underbrace{\text{\texttt{www.someschool.edu/}}}_{\text{host name}}\underbrace{\text{\texttt{someDept/pic.gif}}}_{\text{path name}}$
        \end{center}

    \end{itemize}

  \item HTTP Overview

    \begin{itemize}

      \item HTTP — Hypertext Transfer Protcol

      \item Web's application layer protocol

      \item Client/server model

        \begin{itemize}

          \item Client: Browser that requests, receives (using HTTP protocol) and ``displays'' Web objects

          \item Server: Web server sends (using HTTP protocol) objects in response to requests

        \end{itemize}

      \item Versions

        \begin{itemize}

          \item HTTP/1.0 (RFC1945)

            \begin{itemize}

              \item Original HTTP version (early 1990s)

            \end{itemize}

          \item HTTP/1.1 (RFC7230,\ldots)

            \begin{itemize}

              \item Used by most of the HTTP transactions

            \end{itemize}

          \item HTTP/2 (RFC7540,\ldots)

            \begin{itemize}

              \item Standardized in 2015 and increasingly used by browsers and servers

            \end{itemize}

          \item HTTP/3 (RFC9114)

            \begin{itemize}

              \item IETF published it as a proposed standard in June 2022

            \end{itemize}

        \end{itemize}

      \item HTTP used TCP (except HTTP/3):

        \begin{itemize}

          \item Client initiates TCP connect (creates socket) to server, port 80

          \item Server accepts TCP connection from client

          \item HTTP messages (application-layer protocol messages) exchanged between browser (HTTP client) and Web server (HTTP server)

          \item TCP connection closed

        \end{itemize}

      \item HTTP is ``stateless''

        \begin{itemize}

          \item Server maintains no information about past client requests

        \end{itemize}

      \item Protocols that maintain ``state'' are complex

        \begin{itemize}

          \item Past history (state) must be maintained

          \item If server/client crashes, their view of ``state'' may be inconsistent, must be reconciled

        \end{itemize}

      \item Non-persistent HTTP

        \begin{enumerate}

          \item TCP connection opened

          \item At most one object sent over TCP connection

          \item TCP connection closed

        \end{enumerate}

        \begin{itemize}

          \item Downloading multiple objects requires multiple connections

        \end{itemize}

      \item Persistent HTTP

        \begin{enumerate}

          \item TCP connection opened to a server

          \item Multiple objects can be sent over single TCP connection between client, and that server

          \item TCP connection closed

        \end{enumerate}

      \item RTT (Round-Trip Time) definition: time for a small packet to travel from client to server and back

        \begin{itemize}

          \item Includes propagation, queueing, and processing delays

        \end{itemize}

      \item Non-persistent HTTP response time (per object)

        \begin{itemize}

          \item One RTT to initiate TCP connection

          \item One RTT for HTTP request/response

          \item File/object transmission time

          \item Non-persistent HTTP time $\approx$ 2RTT + transmission time (per object)

        \end{itemize}

      \item Non-persistent HTTP issues:

        \begin{itemize}

          \item Requires 2 RTTs per object

          \item OS overhead for each TCP connection

          \item Browsers often open parallel TCP connections to fetch referenced objects in parallel

        \end{itemize}

      \item Persistent HTTP/1.1:

        \begin{itemize}

          \item Server leaves connection open after sending response

          \item Subsequent HTTP messages between same client/server sent over open connection

          \item Client sends requests as soon as it encounters a referenced object

          \item As little as one RTT for all the referenced objects (cutting response time in half)

        \end{itemize}

      \item HTTP Request Message

        \begin{itemize}

          \item Two types of HTTP messages: request, response

          \item HTTP request message is in ASCII (human-readable format)

        \end{itemize}

    \end{itemize}

  \item HTTP Methods

    \begin{itemize}

      \item GET method

        \begin{itemize}

          \item To request an object

          \item If user data (like form input), the data is included in URL field of HTTP GET request message (following a '?'):

            \begin{center}
              \texttt{ www.somesite.com/animalsearch?table\&chair}
            \end{center}

        \end{itemize}

      \item POST method

        \begin{itemize}

          \item Web page often includes form input

          \item User input sent from client to server in entity body of HTTP POST request message

        \end{itemize}

      \item HEAD method

        \begin{itemize}

          \item Requests headers (only) that would be returned if specified URL were requested  with an HTTP GET method

        \end{itemize}

      \item PUT method

        \begin{itemize}

          \item Uploads new file (object) to server

          \item Completely replaces file that exists at specified URL with content in entity body

        \end{itemize}

      \item DELETE method

        \begin{itemize}

          \item Deletes file specified in the URL field

        \end{itemize}

    \end{itemize}

  \item HTTP Response Status Codes

    \begin{itemize}

      \item 200 — OK

        \begin{itemize}

          \item Request succeeded, requested object later in this message

        \end{itemize}

      \item 301 — Moved Permanently

        \begin{itemize}

          \item Requested object moved, new location specified later in this msg (Location:)

        \end{itemize}

      \item 400 — Bad Request

        \begin{itemize}

          \item Request msg not understood by server

        \end{itemize}

      \item 404 — Not Found

        \begin{itemize}

          \item Requested document not found on this server

        \end{itemize}

      \item 505 HTTP — Version Not Supported

    \end{itemize}

  \item HTTP/2

    \begin{itemize}

      \item Key goal: decreased delay in multiple-object HTTP requests

      \item HTTP/1.1: introduced multiple, pipelined GETs over single TCP connection (persistent HTTP)

        \begin{itemize}

          \item FCFS (First-Come-First-Served) scheduling: server responds in-order to GET requests

          \item Head-Of-Line (HOL) blocking: with FCFS, small object may have to wait for transmission behind large object(s)

          \item Loss recovery (retransmitting lost TCP segments) stalls object transmission

        \end{itemize}

      \item HTTP/2: increased flexibility at server in sending objects to client

        \begin{itemize}

          \item Methods, status codes, most header fields unchanged from HTTP 1.1

          \item Transmission order of requested objects based on client-specified object priority (not necessarily FCFS)

          \item Push unrequested objects to client

          \item Divide objects into frames, schedule frames to mitigate HOL blocking

        \end{itemize}

    \end{itemize}

  \item HTTP/2 to HTTP/3

    \begin{itemize}

      \item HTTP/2 over single TCP connection means:

        \begin{itemize}

          \item Recovery from packet loss still stalls all object transmissions
            
            \begin{itemize}

              \item As in HTTP 1.1, browsers have incentive to open multiple parallel TCP connections to reduce stalling and increase overall application data throughput

            \end{itemize}

          \item No security over vanilla TCP connection

        \end{itemize}

      \item HTTP/3 operates over QUIC, a transport protocol built on UDP

        \begin{itemize}

          \item Adds security, per object error, and congestion-control (more pipelining) over UDP

        \end{itemize}

    \end{itemize}

  \item Maintaining User/Server State: Cookies

    \begin{itemize}

      \item Recall: HTTP GET/response interaction is stateless

      \item Web sites and client browser use cookies to maintain some state between transactions

      \item Four components:

        \begin{enumerate}

          \item Cookie header line of HTTP response message

          \item Cookie header line in next HTTP request message

          \item Cookie file kept on user's host, managed by user's browser

          \item Back-end database at Web site

        \end{enumerate}

    \end{itemize}

  \item HTTP Cookies: Comments

    \begin{itemize}

      \item What cookies can be used for:

        \begin{itemize}

          \item Authorization

          \item Shopping carts

          \item Recommendations

          \item User session state (Web e-mail)

        \end{itemize}

      \item Challenge: How to keep state

        \begin{itemize}

          \item Protocol endpoints: maintain state at sender/receiver over multiple transactions

          \item Cookies: HTTP messages carry state

        \end{itemize}

      \item Cookies and Privacy:

        \begin{itemize}

          \item Cookies permit sites to learn a lot about you on their site

          \item Third party persistent cookies (tracking cookies) allow common identity (cookie value) to he tracked across multiple web sites

        \end{itemize}

    \end{itemize}

  \item Web Caches (Proxy Server)

    \begin{itemize}

      \item Goal: satisfy client request without involving origin server

      \item User configures browser to point to a web cache

      \item Browser sends all HTTP requests to cache

        \begin{itemize}

          \item If object in cache, cache returns object to client

          \item Else cache requests object from origin server, caches received object, then returns object to client

        \end{itemize}

      \item Web cache acts as both client and server

        \begin{itemize}

          \item Server for original requesting client

          \item Client to origin server

        \end{itemize}

      \item Typically, cache is installed by ISP (university, company, residential ISP)

      \item Why Web Caching?

        \begin{itemize}

          \item Reduce response time for client request

            \begin{itemize}

              \item Cache is closer to client

            \end{itemize}

          \item Reduce traffic on an institution's access link

          \item Internet is dense with caches

            \begin{itemize}

              \item Enables ``poor'' content providers to more effectively deliver content

            \end{itemize}

        \end{itemize}

    \end{itemize}

  \item Conditional GET

    \begin{itemize}

      \item Web cache: specify date of cached copy in HTTP request:

        $$\text{\textbf{If-modified-since: $<$date$>$}}$$

      \item Server: response contains no object if cached copy is up-to-date

        $$\text{\textbf{HTTP/1.1 304 Not Modified}}$$

      \item Goal: don't send object if cache has up-to-date cached version

        \begin{itemize}

          \item No object transmission delay

          \item Lower link utilization

        \end{itemize}

    \end{itemize}

  \item E-Mail

    \begin{itemize}

      \item Three major components

        \begin{enumerate}

          \item User agents (UA)

            \begin{itemize}

              \item A.k.a. ``mail reader''

              \item Composing, editing, reading mail messages

              \item E.g., Outlook, iPhone mail client

              \item Outgoing, incoming messages stored on server

            \end{itemize}

          \item Mail servers

            \begin{itemize}

              \item Mailbox contains incoming messages for user

              \item Message queue of outgoing (to be sent) mail messages

            \end{itemize}

          \item Simple Mail Transfer Protocol (SMTP)

            \begin{itemize}

              \item Between mail servers to send e-mail messages

                \begin{itemize}

                  \item Client: Sending mail server

                  \item Server: Receiving mail server

                \end{itemize}

              \item SMTP can also be used by user agents to send e-mails to mail server

            \end{itemize}
            
        \end{enumerate}

    \end{itemize}

  \item E-Mail: SMTP (RFC 5321)

    \begin{itemize}

      \item Uses TCP to reliably transfer e-mail message from client to server (mail server port 25)

      \item Direct transfer: sending mail server (acting like client) to receiving mail server

      \item After TCP connection is established, three phases of transfer

        \begin{itemize}

          \item Handshaking (greeting)

          \item Transfer of messages

          \item Closure

        \end{itemize}

      \item Command/response interaction (like HTTP)

        \begin{itemize}

          \item Commands: ASCII text

          \item Response: status code and phrase

        \end{itemize}

      \item Messages must be in 7-bit ASCII

      \item Comparison with HTTP:

        \begin{itemize}

          \item HTTP: pull; SMTP: push

          \item Both have ASCII command/response interaction and status codes

          \item HTTP: each object encapsulated in its own response message; SMTP: multiple objects sent in multipart message

          \item SMTP: multiple objects sent in multipart message

          \item SMTP uses presistent connections

          \item SMTP requires message (header \& body) to be in 7-bit ASCII

        \end{itemize}

    \end{itemize}

  \item E-Mail Access Protocols

    \begin{itemize}

      \item SMTP: delivery/storage of e-mail messages to receiver's server

      \item E-Mail access protocol: Bob's user agent starts the communication for retrieval from server

        \begin{itemize}

          \item IMAP: Internet Mail Access Protocol (RFC 3501): messages stored on server, IMAP provides retrieval, deletion, folders of stored messages on server

        \end{itemize}

      \item HTTP: Gmail, Hotmail, etc. provides web-based interface to send or to retrieve e-mail messages

    \end{itemize}

  \item Domain Name System (DNS)

    \begin{itemize}

      \item People have many identifiers:

        \begin{itemize}

          \item SSN, name, passport number, etc.

        \end{itemize}

      \item Internet hosts, routers

        \begin{itemize}

          \item IP addresss — used for addressing packets

          \item Name, like \textsc{cs.umass.edu} is used by humans

        \end{itemize}

      \item Distributed database implemented in hierarchy of many name servers

      \item Application-layer protocol: hosts and name servers communicate to resovle names (address/name translation)

        \begin{itemize}

          \item Note: core Internet function, implemented as application-layer protocol

          \item Complexity at network's ``edge''

        \end{itemize}

    \end{itemize}

  \item DNS Services

    \begin{itemize}

      \item Hostname to IP address translation

      \item Host aliasing

        \begin{itemize}

          \item Canonical, alias names

        \end{itemize}

      \item Mail server aliasing

      \item Load distribution

        \begin{itemize}

          \item Replaced Web servers: many IP addresses correspond to one name

        \end{itemize}

      \item Why not centralize DNS?

        \begin{itemize}

          \item Single point of failure

          \item Traffic volume

          \item Distant centralized database

          \item Maintenance

          \item It doesn't scale!

        \end{itemize}

      \item Client wants IP accress for Amazon: \nth{1} approximation:

        \begin{itemize}

          \item Query sent to root server to find .com DNS server (root)

          \item Query sent to .com DNS server to get amazon.com DNS server (top level domain)

          \item Query sent to amazon.com DNS server to get IP address for www.amazon.com (authoritative)

        \end{itemize}

    \end{itemize}

  \item Local DNS Server

    \begin{itemize}

      \item Local DNS Server — helps hosts to resolve a query

      \item Does not strictly belong to hierarchy

      \item Each ISP or institution (residential ISP, company, university) has one

        \begin{itemize}

          \item Also called ``default name server''

        \end{itemize}

      \item When host makes DNS query, query is sent to its local DNS server

        \begin{itemize}

          \item Has local cache of recent name-to-address translation pairs (but may be out of date!)

          \item Acts as proxy, forwards query to hierarchy

        \end{itemize}

    \end{itemize}

  \item DNS: Root Name Servers

    \begin{itemize}

      \item Official, contact-of-last-resort by name servers that cannot resolve name

      \item Root name servers provide the IP addresss of TLD servers

      \item Incredibly important Internet function

        \begin{itemize}

          \item Internet couldn't function without it!

        \end{itemize}

      \item ICANN (Internet Corporation for Assigned Names and Numbers) manages root DNS domain

      \item 13 logical root name ``servers'' worldwide, each ``server'' replicated many times (about 200 servers in the US)

    \end{itemize}

  \item TLD and Authoritative Servers

    \begin{itemize}

      \item Top-level domain (TLD) servers:

        \begin{itemize}

          \item Responsible for .com, .org, .net, .edu, etc.

          \item Network solutions maintains servers for .com, .net TLD

          \item Educause for .edu TLD

        \end{itemize}

      \item Authoritative DNS servers:

        \begin{itemize}

          \item Organization's own DNS server(s), providing authoritative hostname to IP mappings for organizations named hosts

        \end{itemize}

    \end{itemize}

  \item DNS Name Resolution: Iterated Query

    \begin{itemize}

      \item Example: host at \textsc{engineering.nyu.edu} wants IP address for \textsc{gaia.cs.umass.edu}

      \item Iterated Query

        \begin{itemize}

          \item Contacted server replies with name of server to contact

          \item ``I don't know this name, but ask this server''

        \end{itemize}

    \end{itemize}

  \item DNS Name Resolution: Recursive Query

    \begin{itemize}

      \item Same situation as above

      \item Recursive Query

        \begin{itemize}

          \item Puts burden of name resolution on contacted name server

          \item Heavy load at upper levels of hierarchy?

        \end{itemize}

    \end{itemize}

  \item Caching, Updating DNS Records

    \begin{itemize}

      \item Once (any) local DNS server learns mapping, it caches mapping

        \begin{itemize}

          \item Cache entries timeout (disappear) after some time (TTL)

          \item TLD servers typically cached in local name servers

            \begin{itemize}

              \item Thus, root name servers not often visited

            \end{itemize}

          \item Cached entries may be out-of-date (best effort name-to-address translation)

            \begin{itemize}

              \item If name host changes IP address, may not be known Internet-wide until all TTLs expire

            \end{itemize}

          \item Update/notify mechanisms proposed IETF standard

            \begin{itemize}

              \item RFC 2136

            \end{itemize}

        \end{itemize}

    \end{itemize}

  \item DNS Records

    \begin{itemize}

      \item DNS: distributed database storing Resource Records (RR)

        $$\boxed{\text{RR Format: \textsc{(name, value, type, ttl)}}}$$

      \item \textsc{type=A}

        \begin{itemize}

          \item \textsc{name} is hostname

          \item \textsc{value} is IP address

        \end{itemize}

      \item \textsc{type=NS}

        \begin{itemize}

          \item \textsc{name} is domain (e.g., foo.com)

          \item \textsc{value} is hostname of authoritative name server for this domain

        \end{itemize}

      \item \textsc{type=CNAME}

        \begin{itemize}

          \item \textsc{name} is alias name for some ``canonical'' (the real) name

            \begin{itemize}

              \item \textsc{www.ibm.com} is really \textsc{servereast.backup2.ibm.com}

            \end{itemize}

          \item \textsc{value} is canonical name

        \end{itemize}

      \item \textsc{type=MX}

        \begin{itemize}

          \item \textsc{name} is a mail domain

          \item \textsc{value} is hostname of mail server associated with \textsc{name}

        \end{itemize}

    \end{itemize}

  \item DNS Protocol Messages

    \begin{itemize}

      \item DNS query and reply messages, both have same format:

        \begin{itemize}

          \item Message header:

            \begin{itemize}

              \item Identification — 16 bit number for query; reply to query uses same number

              \item Flags — query or reply; recursion desired/available; if reply is authoritative

            \end{itemize}

        \end{itemize}

    \end{itemize}

  \item Inserting Records into DNS

    \begin{itemize}

      \item DNS registrar: commercial entity that verifies the uniqueness of a domain name

        \begin{itemize}

          \item Enters the domain name into the DNS database

          \item Collects a small fee from you for its services

        \end{itemize}

      \item There are many registrars that compete for customers

      \item The ICAAN accredits the various registrars

      \item Example: a new start-up ``Network Utopia''

      \item Register domain name \textsc{networkutopia.com} at some DNS registrat (e.g., Network Solutions)

        \begin{itemize}

          \item Provide names, IP addresses of authoritative name server (primary and secondary)

          \item Registrar inserts NS and A type RRs into .com TLD server for each authoritative name server:

            $$\boxed{\text{\textsc{(networkutopia.com, adns1.networkutopia.com, NS)}}}$$
            $$\boxed{\text{\textsc{(adns1.networkutopia.com, 212.212.212.1, A)}}}$$

        \end{itemize}

      \item Create authoritative server locally with IP address \textsc{212.212.212.1} and enter:

        \begin{itemize}

          \item Type A record for your web server: \textsc{(www.networkutopia.com, ``IP address'', A)}

          \item Type MX record for your mail server:

            $$\boxed{\text{\textsc{(networkutopia.com, mail.networkutopia.com, MX)}}}$$
            $$\boxed{\text{\textsc{(mail.networkutopia.com, "IP address", A)}}}$$

        \end{itemize}

    \end{itemize}

  \item Peer-To-Peer (P2P) Architecture 

    \begin{itemize}

      \item No always-on server

      \item Arbitrary end systems directly communicate

      \item Peers are intermittently connected and change IP addresses

      \item Examples:

        \begin{itemize}

          \item File distribution (BitTorrent)

          \item Streaming (KanKan)

          \item VoIP (Skype)

        \end{itemize}

    \end{itemize}

  \item P2P File Distribution: BitTorrent

    \begin{itemize}

      \item File divided into 256kb chunks

      \item Peers in torrent send/receive file chunks

      \item Tracker: tracks peers participating in torrent

      \item Torrent: group of peers exchanging chunks of a file

      \item Peer joining torrent:

        \begin{itemize}

          \item Has no chunks, but will accumulate them over time from other peers

          \item Registers with tracker to get list of peers, connects to subset of peers (``neighbors'')

        \end{itemize}

      \item While downloading, peer uploads chunks to other peers

      \item Peer may change peers with whom it exchanges chunks

      \item Churn: peers may come and gp

      \item Requesting Chunks:

        \begin{itemize}

          \item At any given time, different peers have different subsets of file chunks

          \item Periodically, a certain peer asks each peer for list of chunks they have

          \item The peer then requests missing chunks from peers, rarest first

        \end{itemize}

      \item Sending Chunks: tit-for-tat

        \begin{itemize}

          \item A peer sends chunks to those four peers currently sending them chunks at highest rate

            \begin{itemize}

              \item Other peers are choked by the peer (do not receive chunks)

              \item Re-evaluate top 4 every 10 seconds

            \end{itemize}

          \item Every 30 seconds randomly ``unchoke'' another peer

          \item Newly chosen peer may join top 4

        \end{itemize}

    \end{itemize}

  \item Video Streaming and CDNs: Context

    \begin{itemize}

      \item Stream video traffic: major consumer of internet bandwidth

        \begin{itemize}

          \item Netflix, YouTube, Amazon Prime: 80\% of residential ISP traffic

        \end{itemize}

      \item Challenge: scale — how to reach about 1B users?

        \begin{itemize}

          \item Single mega-video server won't work

        \end{itemize}

      \item Challenge heterogeneity

        \begin{itemize}

          \item Different users have different capabilities

        \end{itemize}

      \item Solution: distributed, application-level infrastructure

    \end{itemize}

  \item Multimedia: Video

    \begin{itemize}

      \item Video: sequence of images displayed at constant rate

        \begin{itemize}

          \item Like 24 frames per second

        \end{itemize}

      \item Digital image: array of pixels

        \begin{itemize}

          \item Each pixel represented by bits

        \end{itemize}

      \item Coding: use redundancy within and between images to decrese \# used to encode image

        \begin{itemize}

          \item Spatial (within image) — Instead of sending $N$ values of same color (all purple) send only two values: color value (purple) and number of repeated values ($N$)

          \item Temporal (from one image to the next) — Instead of sending complete frame at $i+1$, send only differences from frame $i$

        \end{itemize}

      \item CBR (Constant bit rate): video encoding rate fixed

      \item VBR (Variable bit rate): video encoding rate changes as amount of spatial, temporal coding changes

      \item Examples:

        \begin{itemize}

          \item MPEG1 (CD-ROM) 1.5 Mbps

          \item MPEG2 (DVD) 3-6 Mbps

          \item MPEG4 (Used in Internet) 64kbps-12Mbps

        \end{itemize}

      \item Main challenges:

        \begin{itemize}

          \item Server-to-client rate will varyover time, with changing network congestion levels (in house, in access network, in network core, at video server)

          \item Packet loss and delay due to congestion will delay playout, or result in poor video quality

        \end{itemize}

    \end{itemize}

  \item Streaming stored video

    \begin{itemize}

      \item Continuous playout constraint: once client playout begins, playback must match original timing

        \begin{itemize}

          \item But network delays are variable (jitter), so we will need client-side buffer to match playout requirements

        \end{itemize}

      \item Client-side buffering and playout delay: compensate for network-added delay and jitter

    \end{itemize}

  \item Streaming Multimedia: DASH

    \begin{itemize}

      \item DASH: Dynamic, Adaptive Streaming over HTTP

      \item Server:

        \begin{itemize}

          \item Divides video file into multiple chunks

          \item Each chunk stored, encoded at different rates

          \item Manifest file: provides URLs for different chunks

        \end{itemize}

      \item Client:

        \begin{itemize}

          \item Periodically measures server-to-client transmission rate

          \item Consulting manifest, requests one chunk at a time

            \begin{itemize}

              \item Chooses maximum coding rate sustainable given current transmission rate

              \item Can choose different coding rates at different points in time (depending on available transmission rate at time)

            \end{itemize}

          \item ``Intelligence'' at client: client determines:

            \begin{itemize}

              \item When to request chunk (so that buffer starvation, or overflow, does not occur)

              \item What encoding rate to request (higher quality when more transmission rate available)

              \item Where to request chunk (can request from URL server that is “close” to client or has high available transmission rate)

            \end{itemize}

        \end{itemize}

    \end{itemize}

  \item Content Distribution Networks (CDNs)

    \begin{itemize}

      \item Challenge: how to stream content (selected from millions of videos) to hundreds of thousdands of simultaneous users?

      \item Option 1: single, large ``mega-server''

        \begin{itemize}

          \item Single point of failure

          \item Point of network congestion

          \item Long path to distant clients

          \item Multiple copies of video sent over outgoing link

          \item Doesn't scale!

        \end{itemize}

      \item Option 2: store/server multiple copies of videos at multiple geographically distributed sites (CDN)

        \begin{itemize}

          \item Enter deep: push CDN servers deep into many networks of access ISPs

            \begin{itemize}

              \item Close to users

              \item Akamai, 240000 servers deployed in more than 120 countries

            \end{itemize}

          \item Bring home: smaller number (10's) of larger clusters in POPs (Points of Presence) near (but not within) access ISPs

            \begin{itemize}

              \item Typically, POPs are Internet Exchange Points (IXPs)

              \item Used by Limelight

            \end{itemize}

        \end{itemize}

      \item CDN: stores copies of content at CDN nodes

      \item Subscriber requests content from CDN

        \begin{itemize}

          \item Directed to nearby copy, retrieves content

          \item May choose different copy if network path congested

        \end{itemize}

      \item Over-the-top (OTT)

        \begin{itemize}

          \item OTT challenges: coping with a congested Internet

            \begin{itemize}

              \item From which CDN node to retrieve content?

              \item Viewer behavior in presence of congestion?

              \item What content to place in which CDN node?

            \end{itemize}

        \end{itemize}

    \end{itemize}

\end{itemize}

\end{document}

